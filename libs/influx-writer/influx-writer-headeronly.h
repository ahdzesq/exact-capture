/*Autogenerated on Thu 03 Sep 2020 01:06:50 PM AEST from influx-writer commit ID: 9feb8f18c5208ff5c182cefd603dc126b82977c8*/


#ifndef INFLUX_WRITER_HEADERONLY_H_
#define INFLUX_WRITER_HEADERONLY_H_


#define _POSIX_C_SOURCE  200809L
#ifndef _GNU_SOURCE
  #define _GNU_SOURCE
#endif


/*
 * debug.h
 *
 *  Created on: 2 Sep 2020
 *      Author: mgrosvenor
 */

#ifndef IFWR_DEBUG_H_
#define IFWR_DEBUG_H_
#include <stdbool.h>

/*
 * A little bit of self contained debugging help from
 * https://github.com/mgrosvenor/libchaste/blob/master/utils/debug.c
 */

typedef enum {
    IFWR_DBG,   //Debug message
    IFWR_ERR,   //Error message
    IFWR_FAT,   //Fatal message
    IFWR_WARN   //Warning message
} ifwr_dbg_mode_e;

#define OUTPUT_TO STDERR_FILENO


#define IFWR_ERR( /*format, args*/...)  ifwr_err_helper(__VA_ARGS__, "")
#define ifwr_err_helper(format, ...) ifwr_dbg_out_(true, IFWR_ERR, __LINE__, __FILE__, __func__, format, __VA_ARGS__ )
#define IFWR_ERR2( /*format, args*/...)  ifwr_err_helper2(__VA_ARGS__, "")
#define ifwr_err_helper2(format, ...) ifwr_dbg_out_(false, IFWR_ERR, __LINE__, __FILE__, __func__, format, __VA_ARGS__ )

#define IFWR_FAT( /*format, args*/...)  ifwr_fat_helper(__VA_ARGS__, "")
#define ifwr_fat_helper(format, ...) ifwr_dbg_out_(true, IFWR_FAT, __LINE__, __FILE__, __func__, format, __VA_ARGS__ )
#define IFWR_FAT2( /*format, args*/...)  ifwr_fat_helper2(__VA_ARGS__, "")
#define ifwr_fat_helper2(format, ...) ifwr_dbg_out_(false, IFWR_FAT, __LINE__, __FILE__, __func__, format, __VA_ARGS__ )

#ifndef NDEBUG
    //int ifwr_dbg_out_(ch_bool info, int line_num, const char* filename, const char* function,  const char* format, ... );
    #define IFWR_DBG( /*format, args*/...)  ifwr_dbg_helper(__VA_ARGS__, "")
    #define ifwr_dbg_helper(format, ...) ifwr_dbg_out_(true,IFWR_DBG,__LINE__, __FILE__, __func__, format, __VA_ARGS__ )
    #define IFWR_DBG2( /*format, args*/...)  ifwr_dbg_helper2(__VA_ARGS__, "")
    #define ifwr_dbg_helper2(format, ...) ifwr_dbg_out_(false,IFWR_DBG,__LINE__, __FILE__, __func__, format, __VA_ARGS__ )
    #define IFWR_WARN( /*format, args*/...)  ifwr_dbg_helper3(__VA_ARGS__, "")
    #define ifwr_dbg_helper3(format, ...) ifwr_dbg_out_(true,IFWR_WARN,__LINE__, __FILE__, __func__, format, __VA_ARGS__ )
#else
    #define IFWR_DBG( /*format, args*/...)
    #define IFWR_DBG2( /*format, args*/...)
    #define IFWR_WARN( /*format, args*/...)
#endif

int ifwr_dbg_out_(
        bool info,
        ifwr_dbg_mode_e mode,
        int line_num,
        const char* filename,
        const char* function,
        const char* format, ... );



#endif /* IFWR_DEBUG_H_ */
/*
 * Description: Influx-Writer is a small, simple, InfluxDB 2.0 client for C.
 * 				It enables applications to quickly log values to InfluxDB.
 * 				The library is for writing only, and is designed for speed and
 * 				simplicity. It is not designed or intended as a general purpose
 * 				InfluDB client library.
 *
 * 		 @file: influx-writer.h
 *  Created on: Aug 30, 2020
 *      Author: Matthew P. Grosvenor
 *      Contact <first initial><lastname>@gmail.com
 */

#ifndef INFLUXWRITER_H_
#define INFLUXWRITER_H_


#include <stdint.h>
#include <stdbool.h>


/**
 * @struct Nothing to see here. Opaque structure to hold internal state.
 */
struct ifwr_priv;

/**
 * @enum Error types for Influx-Writer
 */
typedef enum
{
	IFWR_ERR_NONE, 		/**< No error. Everything is good :-) */
	IFWR_ERR_NULLARG, 	/**< Argument supplied was null */
	IFWR_ERR_BADARGS, 	/**< Arguments supplied were bad */
	IFWR_ERR_SOCKET,	/**< Could not create socket */
	IFWR_ERR_HOSTNAME, 	/**< Could not resolve hostname */
	IFWR_ERR_CONNECT, 	/**< Could not connect or disconnected */
	IFWR_ERR_NOMEM,		/**< Could not allocate memory */
	IFWR_ERR_NOMEASURE, /**< No measurement name set. Can't send one! */
	IFWR_ERR_NOTAGS,	/**< Tried to send a measurement with no tagset */
	IFWR_ERR_NOFIELDS,	/**< Tried to send a measurement with no fields */
	IFWR_ERR_MSGTOOBIG, /**< Message exceeds max message size */
	IFWR_ERR_WRITEFAIL, /**< Failed to write to a file descriptor */
	IFWR_ERR_NOHEADER,  /**< Failed to write or create HTTP header */
	IFWR_ERR_NOCONTENT, /**< Failed to write or create HTTP content */
	IFWR_ERR_NOTSFMT,   /**< No timestamp format type set */
    IFWR_ERR_NOTIME,    /**< Could not get the time from the local Linux clock*/
    IFWR_ERR_BADHTTP,   /**< Bad HTTP response message */

	//*** !! Don't forget to update ifwr_err2str() and ifwr_errs_en[]. !! ***

	IFWR_ERR_UNKNOWN,	/**< An unknown error occurred */
} ifwr_err_e;


//Cap the maximum message size at 64K. Because it seems silly to leave it
//uncapped
#define IFWR_MAX_MSG 64 * 1024

typedef struct ifwr_priv
{
    ifwr_err_e last_err;
    int sockfd;
    char rx_buff[IFWR_MAX_MSG];
    char* default_measurement;
    char* default_tagset;
    int http_err_code;
    char* json_err_str;
} ifwr_priv_t;


/**
 * @struct Influx-Writer connection state. Supply parameters here to set up
 * 		and maintain the connection.
 */
typedef struct
{
	char* hostname; /**< Hostname string e.g "example.com" */
	int   port;		/**< Host port e.g. 9999 */
	char* org;		/**< Organization string (as supplied by InfluxDB */
	char* bucket;   /**< Bucket identifier (as supplied by InfluxDB */
	char* token;	/**< Authorization toke (as supplied by InfluxDB */

	struct ifwr_priv __private; //Don't touch my privates
} ifwr_conn_t;


/**
 * @brief Return the last error code
 *
 * @param[in] conn
 * 		InfluxDB connection State
 *
 */
ifwr_err_e ifwr_lasterr(ifwr_conn_t* conn );


/**
 * @brief Convert error code to string
 * TODO: Should take into account locale
 */
char* ifwr_err2str(ifwr_err_e err);


/**
 * @brief Convenience function to return the last error as a string
 */
char* ifwr_lasterr_str(ifwr_conn_t* conn );


/**
 * @brief Connect to the InfluxDB instance.
 *
 * @param[in,out]  conn
 * 		InfluxDB connection state with all public details supplied
 * @return 0 on success, -1 on failure. Failure may be:
 * 		IFWR_ERR_NULLARG an argument supplied is NULL (and should not be)
 * 		IFWR_ERR_BADARGS an argument supplied is unexpected
 * 		IFWR_ERR_CONNECT a connection could not be established
 */
int ifwr_connect(ifwr_conn_t* conn );


/**
 * @brief Set the default measurement name that we're working with.
 *
 * @param[in]	conn
 * 		InfluxDB connection state
 * @param[in]	measurement
 * 		Name of the measurement (see InfluxDB line protocol descrition)
 * @return
 * 		0 on success
 */
int ifwr_set_measurement(ifwr_conn_t* conn, char* measurement);


/**
 * @enum InfluxDB only supports a few predefined types, use this to help build
 * 		and format them.
 */
typedef enum
{
	IFWR_TYPE_UNKOWN = 0, 	/**< Type value is unknown or unset */
	IFWR_TYPE_INT,			/**< Type value is an integer (int64_t) */
	IFWR_TYPE_FLOAT,		/**< Type value is a float (double) */
	IFWR_TYPE_STRING,		/**< Type value is a string (char*) */
	IFWR_TYPE_BOOL,			/**< Type value is a boolean (bool) */
	IFWR_TYPE_STOP 		 	/**< Signals end of an array */
} ifwr_type_e;

/**
 * @union Storage type to hold the superset of all supported types
 */
typedef union
{
	int64_t i;
	double f;
	bool   b;
	char* s;
} ifwr_value_u;


/**
 * @struct Helper to build InfluxDB key/value pairs
 */
typedef struct
{
	char* key;
	ifwr_type_e type;
	ifwr_value_u value;
} ifwr_ktv_t;


/**
 * @brief Format a tagset into an InfluxDB Line Protocol string
 *
 * @param[in]	conn
 * 		InfluxDB connection state
 * @param[in] 	values
 * 		Array of Influx-writer type/values pairs
 * @param[in] len
 * 		maximum size of output
 * @param[in,out] buff
 * 		buffer to put string into
 *
 * @return Number of bytes written to the string, -1 on error
 */
int ifwr_fmt_tagset(ifwr_conn_t* conn, ifwr_ktv_t* values, int len, char* buff);


/**
 * @brief Set the default tagset for each measurement
 */
int ifwr_set_tagset(ifwr_conn_t* conn, char* tagset);


/**
 * @brief Format a feildset into an InfluxDB Line Protocol string
 *
 * @param[in]	conn
 * 		InfluxDB connection state
 * @param[in] 	values
 * 		Array of Influx-writer type/values pairs
 * @param[in] len
 * 		maximum size of output
 * @param[in,out] buff
 * 		buffer to put string into
 *
 * @return Number of bytes written to the string, -1 on error
 */
int ifwr_fmt_fieldset(ifwr_conn_t* conn, ifwr_ktv_t* values, int len, char* buff);

/**
 * @enum Set the measurement timestamp precision
 */
typedef enum
{
    IFWR_TS_UNDEF 	= 0,	/**< Undefined or not set */
    IFWR_TS_LOCAL,			/**< No timestamp supplied. Use local time */
    IFWR_TS_REMOTE, 		/**< No timesatmp supplied. Use InfluxDB time */
    IFWR_TS_SECS,			/**< Seconds only */
    IFWR_TS_MILLIS,			/**< Milliseconds */
    IFWR_TS_MICROS,			/**< Microseconds */
    IFWR_TS_NANOS,			/**< Nanoseconds */
} ifwr_fmt_e;


/**
 * @brief Send a measurement to InfluxDB
 *
 * @param[in]	conn
 * 		InfluxDB connection state
 * @param[in]	measure
 * 		measurement name, if NULL, use the default
 * @param[in] tags
 * 		InfluxDB Line protocol tag set, if NULL, the the default
 * @param[in] fields
 * 		InfluxDB Line protocol field set, cannot be NULL!
 * @param   fmt
 *      Timesatmp format
 * @param[in] ts
 * 		Timesatmp value in Unix epoch format with precision as above

 *
 * @return Number of bytes written to the string, -1 on error
 */
int ifwr_send(
		ifwr_conn_t* conn,
		const char* measurement,
		const ifwr_ktv_t* tags,
		const ifwr_ktv_t* fields,
        ifwr_fmt_e ts_fmt,
		int64_t ts_val);

/**
 * @brief Danger! Send whatever you provide to the InfluxDB endpoint.
 *
 * Use this only if you want to hand craft the line protocol input to influx
 *
 * @param[in]  conn
 * 		InfluxDB connection state
 * @param[in] format
 * 		C-style (printf) format string which will result in a valid InfluxDB
 * 		line protocol string once formatted
 * @param[in] ...
 * 		C-style (printf) arguments (for above)
 *
 * @return The number of bytes written
 */
__attribute__((__format__ (__printf__, 3, 4)))
int ifwr_write_raw(ifwr_conn_t* conn, const char* prec, const char* format, ... );

/**
 * @brief Get the result of a ifwr_write_raw(), or ifwr_send() functions.
 *
 * @param[in]  conn
 *      InfluxDB connection state
 *
 * @return 0 on success, -1 on failure. If failure, the http_err number can be
 */
int ifwr_response(ifwr_conn_t* conn);

/**
 * @brief Return the HTTP error code for the last write. Must be run after
 *      get_write_result() has been run
 *
 * @param[in]  conn
 *      InfluxDB connection state
 * @param[out] jason_msg
 *      Pointer to a string which will contain the JSON error message returned.
 *
 * @return the last HTTP error status number (typically ~400) for an error.
 */
int ifwr_http_err(ifwr_conn_t* conn, char** json_msg);



/**
 * @brief Close the connection to InfluxDB
 *
 * @param[in]	conn
 * 		InfluxDB connection state
 *
 */
void ifwr_close(ifwr_conn_t* conn);

#endif /* INFLUXWRITER_H_ */
/*
 * debug.c
 *
 *  Created on: 2 Sep 2020
 *      Author: mgrosvenor
 */

#define _POSIX_C_SOURCE  200809L

#ifndef _GNU_SOURCE
	#define _GNU_SOURCE
#endif

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdarg.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <libgen.h>




int ifwr_dbg_out_(
        bool info,
        ifwr_dbg_mode_e mode,
        int line_num,
        const char* filename,
        const char* function,
        const char* format, ... ) //Intentionally using char* here as these are passed in as constants
{
    va_list args;
    va_start(args,format);
    char* fn =  (char*)filename;
    char* mode_str = NULL;
    switch(mode){
        case IFWR_ERR:   mode_str = "Error"; break;
        case IFWR_FAT:   mode_str = "Fatal"; break;
        case IFWR_DBG:   mode_str = "Debug"; break;
        case IFWR_WARN:  mode_str = "Warning:"; break;
    }
    if(info) dprintf(OUTPUT_TO,"[%s - %s:%i:%s()]  ", mode_str, basename(fn), (int)line_num, function);
    int result = vdprintf(OUTPUT_TO,format,args);
    va_end(args);

    if(mode == IFWR_FAT){
        exit(-1);
    }

    return result;
}
/*
 * influx-writer.c
 *
 *  Created on: Aug 30, 2020
 *      Author: Matthew P. Grosvenor
 */

#define _POSIX_C_SOURCE  200809L
#ifndef _GNU_SOURCE
	#define _GNU_SOURCE
#endif


#include <stdbool.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <stdarg.h>
#include <libgen.h>
#include <unistd.h>
#include <ctype.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <arpa/inet.h>
#include <inttypes.h>




#define IFWR_SET_ERROR(errno) do { \
		conn->__private.last_err = errno; \
} while (0)




ifwr_err_e ifwr_lasterr(ifwr_conn_t* conn )
{
	return conn->__private.last_err;
}


static char* ifwr_errs_en[] = {
	"No error. Everything is good",
	"Require argument supplied is null",
	"Arguments supplied were bad",
	"Could not create socket",
	"Could not resovle hostname",
	"Could not connect or disconnected",
	"Could not allocate memory",
	"No measurement name set. Can't send one!",
	"Tried to send a measurement with no tagset",
	"Tried to send a measurement with no fields",
	"Message exceeds maximum message size",
	"Could not write to file descriptor",
	"Failed to write or create HTTP header",
    "Failed to write or create HTTP content",
    "No timestamp format type set",
    "Could not get the time from the local Linux clock",
    "Bad HTTP response message",

	"An unknown error occurred"
};


char* ifwr_err2str(ifwr_err_e err)
{
	switch(err){
		case IFWR_ERR_NONE: 		return ifwr_errs_en[0];
		case IFWR_ERR_NULLARG: 		return ifwr_errs_en[1];
		case IFWR_ERR_BADARGS: 		return ifwr_errs_en[2];
		case IFWR_ERR_SOCKET: 		return ifwr_errs_en[3];
		case IFWR_ERR_HOSTNAME:		return ifwr_errs_en[4];
		case IFWR_ERR_CONNECT: 		return ifwr_errs_en[5];
		case IFWR_ERR_NOMEM: 		return ifwr_errs_en[6];
		case IFWR_ERR_NOMEASURE: 	return ifwr_errs_en[7];
		case IFWR_ERR_NOTAGS: 		return ifwr_errs_en[8];
		case IFWR_ERR_NOFIELDS: 	return ifwr_errs_en[9];
		case IFWR_ERR_MSGTOOBIG:	return ifwr_errs_en[10];
		case IFWR_ERR_WRITEFAIL:    return ifwr_errs_en[11];
		case IFWR_ERR_NOHEADER:     return ifwr_errs_en[12];
        case IFWR_ERR_NOCONTENT:    return ifwr_errs_en[13];
        case IFWR_ERR_NOTSFMT:      return ifwr_errs_en[14];
        case IFWR_ERR_NOTIME:       return ifwr_errs_en[15];
        case IFWR_ERR_BADHTTP:      return ifwr_errs_en[16];

		case IFWR_ERR_UNKNOWN: return ifwr_errs_en[17];

		/* default: Deliberately no default case, let the compiler complain if
		 * we forget to add new error codes here!
		 */
	}

	return ifwr_errs_en[17];
}


char* ifwr_lasterr_str(ifwr_conn_t* conn )
{
	return(ifwr_err2str(ifwr_lasterr(conn)));
}


static int resolve_host(const char* hostname, struct in_addr* out)
{
    struct hostent* he = NULL;
    if ((he = gethostbyname(hostname)) == NULL)
    {
        // get the host info
        IFWR_DBG("Error getting hostname: %s\n", strerror(errno));
        return -1;
    }

    struct in_addr** addr_list = (struct in_addr**) he->h_addr_list;

    for(int i = 0; addr_list[i]; i++)
    {
        //Return the first one;
        *out = *addr_list[0];

        char str[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, out, str, INET_ADDRSTRLEN);

        IFWR_DBG("Success! Host resolved. Returning address %s\n", str);
        return 0;
    }

    IFWR_DBG("Error no IP addresses found!\n");
    return -1;
}



int ifwr_connect(ifwr_conn_t* conn )
{
	if(!conn){
		IFWR_DBG("No connection supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_NULLARG);
		return -1;
	}

	if(!conn->hostname){
		IFWR_DBG("No hostname supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_BADARGS);
		return -1;
	}

	if(conn->port < 0 || conn->port > 65536){
		IFWR_DBG("Port number should be in the range [0..65536]\n");
		IFWR_SET_ERROR(IFWR_ERR_BADARGS);
		return -1;
	}

	if(!conn->org){
		IFWR_DBG("No organization ID supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_BADARGS);
		return -1;
	}

	if(!conn->bucket){
		IFWR_DBG("No bucket ID supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_BADARGS);
		return -1;
	}

	if(!conn->token){
		IFWR_DBG("No authorization token supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_BADARGS);
		return -1;
	}

	ifwr_priv_t* const priv = &conn->__private;

	priv->sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (priv->sockfd == -1) {
		IFWR_DBG("Socket creation failed...\n");
		IFWR_SET_ERROR(IFWR_ERR_SOCKET);
		return -1;
	}

	IFWR_DBG("Socket successfully created..\n");

	struct sockaddr_in servaddr = {0};
	if(resolve_host(conn->hostname,&servaddr.sin_addr)){
		IFWR_DBG("Error, could not resolve hostname %s\n", conn->hostname);
		IFWR_SET_ERROR(IFWR_ERR_HOSTNAME);
		return -1;
	}

	servaddr.sin_family         = AF_INET;
	servaddr.sin_port           = htons(conn->port);

	// connect the client socket to server socket
	if (connect(priv->sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) != 0) {
		IFWR_DBG("connection with the server failed...\n");
		IFWR_SET_ERROR(IFWR_ERR_CONNECT);
		return -1;
	}

	IFWR_DBG("Success! Connected to the server %s:%i..\n",
			conn->hostname,
			conn->port);

	return 0;
}

void ifwr_close(ifwr_conn_t* conn)
{
    if(!conn){
        IFWR_DBG("No connection state supplied\n");
        IFWR_SET_ERROR(IFWR_ERR_NULLARG);
        return;
    }

    ifwr_priv_t* const priv = &conn->__private;
    close(priv->sockfd);

    IFWR_DBG("Success! Closed the socket!\n");

}


int ifwr_set_measurement(ifwr_conn_t* conn, char* measurement)
{
	if(!conn){
		IFWR_DBG("No connection supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_NULLARG);
		return -1;
	}

	if(!measurement){
		IFWR_DBG("No measurement name supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_BADARGS);
		return -1;
	}

	ifwr_priv_t* const priv = &conn->__private;

	priv->default_measurement = measurement;

	IFWR_DBG("Success! Set the default measuremt to \"%s\"\n", measurement);
	return 0;
}


static int ifwr_fmt_set(
		ifwr_conn_t* conn,
		ifwr_ktv_t* values,
		int len,
		char* buff,
		const char* settype //"tag"set or "field"set
)
{
	if(!conn){
		IFWR_DBG("No connection state supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_NULLARG);
		return -1;
	}

	if(!buff){
		IFWR_DBG("No outut buffer supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_BADARGS);
		return -1;
	}

	if(len < 0){
		IFWR_DBG("No output buffer supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_BADARGS);
		return -1;
	}

	if(len > IFWR_MAX_MSG){
		IFWR_DBG("Buffer is too big\n");
		IFWR_SET_ERROR(IFWR_ERR_MSGTOOBIG);
		return -1;
	}

	int off = 0;
	for(ifwr_ktv_t* v = values;  v->type != IFWR_TYPE_STOP; v++){
		switch(v->type){
		case IFWR_TYPE_INT:
			off += snprintf(buff + off, len - off, "%s=%" PRIu64 "i,", v->key, v->value.i);
			continue;
		case IFWR_TYPE_FLOAT:
			off += snprintf(buff + off, len - off, "%s=%lf,", v->key, v->value.f);
			continue;
		case IFWR_TYPE_STRING:
			off += snprintf(buff + off, len - off, "%s=\"%s\",", v->key, v->value.s);
			continue;
		case IFWR_TYPE_BOOL:
			if(v->value.b)
				off += snprintf(buff + off, len - off, "%s=True,", v->key);
			else
				off += snprintf(buff + off, len - off, "%s=False,", v->key);
			continue;
		default:
			IFWR_DBG("Unexpected type %i\n", v->type);
			IFWR_SET_ERROR(IFWR_ERR_UNKNOWN);
			return -1;
		}
	}

	/*
	 * As we exit this function, we have one too many trailing commas, remove
	 * and terminate the string properly.
	 */
	buff[off] = 0;
	off--;

	IFWR_DBG("Successfully formatted %sset \"%s\"\n", settype, buff);
	return off;

}

int ifwr_fmt_tagset(ifwr_conn_t* conn, ifwr_ktv_t* values, int len, char* buff)
{
	return ifwr_fmt_set(conn, values, len, buff, "tag");
}


int ifwr_set_tagset(ifwr_conn_t* conn, char* tagset)
{
	if(!conn){
		IFWR_DBG("No connection supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_NULLARG);
		return -1;
	}

	if(!tagset){
		IFWR_DBG("No tagset name supplied\n");
		IFWR_SET_ERROR(IFWR_ERR_BADARGS);
		return -1;
	}

	ifwr_priv_t* const priv = &conn->__private;

	priv->default_tagset = tagset;

	IFWR_DBG("Success! Set the default tagset to \"%s\"\n", tagset);
	return 0;
}



int ifwr_fmt_fieldset(ifwr_conn_t* conn, ifwr_ktv_t* values, int len, char* buff)
{
	return ifwr_fmt_set(conn, values, len, buff, "field");
}

static int http_write(ifwr_conn_t* conn, const char* type, const char* buff, int len)
{
    ifwr_priv_t* const priv = &conn->__private;

    int written = 0;
    int attempts_remaing = 1000;
    IFWR_DBG("Trying to write %i bytes of HTTP %s \"%s\"", len, type, buff);
    for(;len - written > 0 && attempts_remaing; attempts_remaing--){
        int ret = write(priv->sockfd, buff + written, len - written);
        if(ret < 0){
            IFWR_ERR("Could not write %s. Error: %s", type, strerror(errno));
            IFWR_SET_ERROR(IFWR_ERR_WRITEFAIL);
            return -1;
        }
        written += ret;
    }

    if(written != len || attempts_remaing <= 0){
        IFWR_DBG("Error could not write values! Tried 1000 times but failed\n");
        IFWR_SET_ERROR(IFWR_ERR_WRITEFAIL);
        return -1;
    }

    IFWR_DBG("Success! Wrote %i bytes of HTTP %s\n", written);
    return written;
}


static int http_post_header(ifwr_conn_t* conn, int content_len, const char* prec)
{
    char buff[IFWR_MAX_MSG] = {0};

    int header_len = snprintf(buff, IFWR_MAX_MSG, "POST /api/v2/write?org=%s&bucket=%s&precision=%s HTTP/1.1\r\nHost: %s:%i\r\nContent-Length: %i\r\nContent-Encoding: identity\r\nContent-Type: text/plain\r\nAccept: application/json\r\nAuthorization: Token %s\r\nUser-Agent: exact-capture-influx 1.0\r\n\r\n",
        conn->org,
		conn->bucket,
		prec,
		conn->hostname,
		conn->port,
        content_len,
		conn->token);

   return http_write(conn, "Header", buff, header_len);
}


static int http_post_content(ifwr_conn_t* conn, const char* content, int content_len)
{
    return http_write(conn, "Content", content, content_len);
}



__attribute__((__format__ (__printf__, 3, 4)))
int ifwr_write_raw(ifwr_conn_t* conn, const char* prec, const char* format, ... )
{
    char content[IFWR_MAX_MSG] = {0};
    va_list args;
    va_start(args,format);
    int content_len = vsnprintf(content, IFWR_MAX_MSG,format, args);
    va_end(args);

    int sent_bytes = 0;
    int ret = http_post_header(conn, content_len, prec);
    if(ret < 0){
        IFWR_ERR("Could not send HTTP header!");
        return -1;
    }
    sent_bytes += ret;

    ret = http_post_content(conn,content, content_len);
    if(ret < 0){
        IFWR_SET_ERROR(IFWR_ERR_NOCONTENT);
        ifwr_close(conn);
        IFWR_FAT("HTTP Header sent, but content failed to send. Closing. Nothing useful to be done here!\n");
        return -1;
    }
    sent_bytes += ret;

    return sent_bytes;

}

static int ktv2str(char* buff, int buff_len, const ifwr_ktv_t* ktv )
{
    int written = 0;
    for(const ifwr_ktv_t* curr = ktv; curr->type != IFWR_TYPE_STOP; curr++){
        switch(curr->type){
            case IFWR_TYPE_STOP:
                //Impossible ? -- handled above
                IFWR_FAT("Impossible situation has happend!?\n");
                break;

            case IFWR_TYPE_BOOL:
                if(curr->value.b){
                    written += snprintf(buff + written, buff_len - written,"%s=True,", curr->key );
                }
                else{
                    written += snprintf(buff + written, buff_len - written,"%s=False,", curr->key );
                }
                continue;

            case IFWR_TYPE_FLOAT:
                written += snprintf(buff + written, buff_len - written,"%s=%lf,", curr->key, curr->value.f );
                continue;

            case IFWR_TYPE_INT:
                written += snprintf(buff + written, buff_len - written,"%s=%" PRIu64 "i,", curr->key, curr->value.i );
                continue;

            case IFWR_TYPE_STRING:
                written += snprintf(buff + written, buff_len - written,"%s=\"%s\",", curr->key, curr->value.s );
                continue;

            case IFWR_TYPE_UNKOWN:
                IFWR_ERR("Found a type of UNKOWN, was your KTV unitialised?\n");
                break;

        }
    }

    //Remove the tailing "," , replace with a null terminator
    if(buff_len - written > 0){
        buff[written -1] = 0;
    }

    return written;
}


//Take a look at the InfluxDB line protocol specification to see what this
//function is trying to build:
//https://v2.docs.influxdata.com/v2.0/reference/syntax/line-protocol/
int ifwr_send(
		ifwr_conn_t* conn,
		const char* measurement,
		const ifwr_ktv_t* tags,
		const ifwr_ktv_t* fields,
		ifwr_fmt_e ts_fmt,
		int64_t ts_val
		)
{
    if(!conn){
        IFWR_DBG("No connection supplied\n");
        IFWR_SET_ERROR(IFWR_ERR_NULLARG);
        return -1;
    }

    ifwr_priv_t* const priv = &conn->__private;

    //Figure out the measurement name
    if(!measurement){
        if(!priv->default_measurement){
            IFWR_SET_ERROR(IFWR_ERR_NOMEASURE);
            IFWR_ERR("No default measurement name is set\n");
            return -1;
        }

        measurement = priv->default_measurement;
    }
    IFWR_DBG("Measurement set to \"%s\"\n", measurement);

    //Figure out the tags
    char* tags_str = NULL;
    if(!tags){
        if(!priv->default_tagset){
            IFWR_SET_ERROR(IFWR_ERR_NOTAGS);
            IFWR_ERR("No default tagset is set\n");
            return -1;
        }
        tags_str = priv->default_tagset;
    }
    else{
        char tmp_tags[IFWR_MAX_MSG] = {0};
        ktv2str(tmp_tags, IFWR_MAX_MSG, tags);
        tags_str = tmp_tags;
    }
    IFWR_DBG("Tags set to \"%s\"\n", tags_str);

    //Figure out the fields
    char fields_str[IFWR_MAX_MSG] = {0};
    if(!fields){
        IFWR_SET_ERROR(IFWR_ERR_NOFIELDS);
        IFWR_ERR("No measurement fields supplied!\n");
        return -1;
    }

    ktv2str(fields_str, IFWR_MAX_MSG, fields);
    IFWR_DBG("Fields set to \"%s\"\n", fields_str);


    //Figure out the timestamp
    char* prec = NULL;
    #define TS_LEN_MAX 64
    char ts_str_tmp[TS_LEN_MAX] = {0};
    char* ts_str = NULL;

    switch(ts_fmt){
        case IFWR_TS_UNDEF:
            IFWR_SET_ERROR(IFWR_ERR_NOTIME);
            IFWR_ERR("No timestamp value set!\n");
            return -1;
        case IFWR_TS_LOCAL:{
            struct timespec now_ts = {0};
            if(clock_gettime(CLOCK_REALTIME, &now_ts) < 0){
                IFWR_ERR("Could not get time! Error: %s", strerror(errno));
                IFWR_SET_ERROR(IFWR_ERR_NOTIME);
                return -1;
            }

            int64_t ns = now_ts.tv_sec * 1000 * 1000 * 1000 + now_ts.tv_nsec;

            prec = "ns";
            snprintf(ts_str_tmp,TS_LEN_MAX,"%" PRIu64,ns);
            ts_str = ts_str_tmp;
            break;
        }
        case IFWR_TS_REMOTE:
            prec = "ms"; //This seems sane. How are you going to get better than
                         //this over the network with a remote timestamp?
            ts_str = "";
            break;
        case IFWR_TS_NANOS:
            prec = "ns";
            //TODO - some sanity check that this is a sensible nanosecond value
            snprintf(ts_str_tmp,TS_LEN_MAX,"%" PRIu64 ,ts_val);
            ts_str = ts_str_tmp;
            break;
        case IFWR_TS_MICROS:
            prec = "us";
            //TODO - some sanity check that this is a sensible microsecond value
            snprintf(ts_str_tmp,TS_LEN_MAX,"%" PRIu64,ts_val);
            ts_str = ts_str_tmp;
            break;
        case IFWR_TS_MILLIS:
            prec = "ms";
            //TODO - some sanity check that this is a sensible milliscecond value
            snprintf(ts_str_tmp,TS_LEN_MAX,"%" PRIu64,ts_val);
            ts_str = ts_str_tmp;
            break;
        case IFWR_TS_SECS:
            prec = "s";
            //TODO - some sanity check that this is a sensible seconds value
            snprintf(ts_str_tmp,TS_LEN_MAX,"%" PRIu64,ts_val);
            ts_str = ts_str_tmp;
            break;

         /*default: no default case intentional. Let the compiler pick up if
          * I've forgotten a value.
          * */
    }
    IFWR_DBG("Timestamp precision is \"%s\"\n", prec);
    IFWR_DBG("Timestamp string is \"%s\"\n ", ts_str_tmp);


    //At this point we have strings for everything, just need to format it
    return ifwr_write_raw(conn, prec, "%s,%s %s %s\r\n",
            measurement,
            tags_str,
            fields_str,
            ts_str);

}


int ifwr_response(ifwr_conn_t* conn)
{
    if(!conn){
          IFWR_DBG("No connection supplied\n");
          IFWR_SET_ERROR(IFWR_ERR_NULLARG);
          return -1;
      }

    ifwr_priv_t* const priv = &conn->__private;


    int len = read(priv->sockfd, priv->rx_buff, IFWR_MAX_MSG);
    if(len == 0){
    	IFWR_ERR("Connection to InfluxDB has been closed by the remote end\n");
    	IFWR_SET_ERROR(IFWR_ERR_CONNECT);
    	return -1;
    }

    if(len < 14){ //HTTP header string should be at least 14 bytes
    	IFWR_ERR("Connection failed to return a valid responsed\n");
    	IFWR_SET_ERROR(IFWR_ERR_CONNECT);
    	return -1;
    }

    char* token = strtok(priv->rx_buff,"\r\n");

    //Check if we've got a correct HTTP header
    if(memcmp(token,"HTTP/1.1 ",9) != 0){
        IFWR_ERR("Could not interpret \"%s\" as an HTTP header response\n", token);
        IFWR_SET_ERROR(IFWR_ERR_BADHTTP);
        return -1;

    }

    //Grab the response code
    char err[4] = {0};
    char* end;
    memcpy(err,token + 9,3);
    long http_err_code = strtol(err,&end,10);
    if(end == err){
        IFWR_ERR("No error code found in HTTP header response \"%s\"\n", token);
        IFWR_SET_ERROR(IFWR_ERR_BADHTTP);
        return -1;
    }

    priv->http_err_code = http_err_code;
    if(http_err_code >= 200 && http_err_code < 300 ){
        IFWR_DBG("Success with HTTP response code %li\n", http_err_code);
        priv->json_err_str = NULL;
        return 0;
    }

    token = strtok(NULL,"\r\n");
    while(token != NULL){
        if(token[0] == '{'){ //HACK! Assume the error line is JSON and starts with "{"
            IFWR_DBG("Failure with HTTP response code %li, message \"%s\"\n", http_err_code, token );
            priv->json_err_str = token;
            return -1;
        }
        token = strtok(NULL,"\r\n");
    }

    //If we get here, we never found the Jason line!
    IFWR_DBG("Could not find JSON response. Bad HTTP message?\n");
    IFWR_SET_ERROR(IFWR_ERR_BADHTTP);
    return -1;
}

int ifwr_http_err(ifwr_conn_t* conn, char** json_msg)
{
    if(!conn){
          IFWR_DBG("No connection supplied\n");
          IFWR_SET_ERROR(IFWR_ERR_NULLARG);
          return -1;
      }

    ifwr_priv_t* const priv = &conn->__private;

    *json_msg = priv->json_err_str;
    return priv->http_err_code;
}



#endif /*INFLUX_WRITER_HEADERONLY_H_*/

